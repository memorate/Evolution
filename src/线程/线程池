###线程：
　1）线程，是程序执行的最小单元。  
　2）标准的线程由线程ID、当前指令指针、寄存器集合和堆栈组成。  
　3）线程是进程中的一个实体，是被系统独立调度和分配的基本单位。  
　4）线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程的全部资源。  
　5）一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。  

###Java中线程的三种基本用法
　1）自定义一个类，去继承Thread类，重写run方法。  
　2）自定义一个类，去实现Runnable接口，重写run方法。  
　3）自定义一个类，去实现Callable接口，重写call方法。  
　注意：Runnable中run方法无返回值且不能抛出异常，Callable中的call方法可返回一个Future对象且可以抛出异常。

###并行和并发  
#####1）并发(Concurrency)：  
　　 a.多个任务可在同一时间段内启动、运行和完成。  
　　 b.在宏观上并发看起来是同时进行，但在微观上(CPU中)是顺序执行的。  
　　 c.并发实质是一个(也可以是多个)物理CPU在多个线程间的复用，但在同一CPU中一个CPU时间片段上只能有一个线程在运行。  
　　 d.由于CPU运行速度快，使得多个任务在极短时间内同时完成，这一现象看起来像是任务的并行运行，但实际上在极小时间粒度(ns)上来看这些任务还是顺序执行的。
#####２）并行(Parallelism)：  
　　 a.并行是真正意义上的多个任务(线程)在宏观、微观中同一时刻运行。  
　　 b.并行只能发生在多核CPU的计算机上。  
　　 c.并行实质上是多个任务分别在多个CPU中在同一时间段内同时运行。  

###线程的五种状态
　1）新建状态：新创建了一个线程对象。  
　2）就绪状态：调用Thread类的start方法()启动一个线程之后，线程进入就绪状态。  
　3）运行状态：当就绪状态的线程获得CPU时间之后，进入运行状态。  
　4）阻塞状态：运行状态中的线程没有结束运行，暂时让出CPU，此时该线程进入阻塞状态，等待下次获得CPU时间。  
　　　a.线程通过调用sleep()方法进入睡眠状态（让出CPU执行权）  
　　　b.线程调用一个在I/O上被阻塞的操作，即该操作在I/O操作完成之前不会返回它的调用者  
　　　c.线程试图得到一个锁，而该锁正被其他线程持有  
　　　d.线程等待某个触发条件  
　5）死亡状态：线程的run()方法正常执行结束或者一个未捕获的异常使线程猝死后线程进入死亡状态。    

###线程的几个常用方法
　1）sleep()  
　　a.使当前线程睡眠指定的一段时间，若该线程持有同步锁，sleep不会让出该锁。  
　　b.线程睡眠到期后自动苏醒，并返回就绪状态，而不是运行状态。因此sleep()中指定的时间是线程不会运行的最短时间，sleep方法不能作为精确的时间控制。  
　　c.sleep是Thread类中的静态方法，只能控制当前正在运行的线程。  
　　d.sleep(0)的作用是触发操作系统重新进行一次CPU竞争，重新计算优先级。竞争的结果也许是当前线程任然获得CPU控制权，也许是其他线程获得。  
　2）wait()  
　　a.  
　　b.  
　　c.  
　3）notify()：  
　4）notifyAll()：  
　5）yield()：  
　6）join()：  