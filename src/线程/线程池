###线程：
　1）线程，是程序执行的最小单元。  
　2）标准的线程由线程ID、当前指令指针、寄存器集合和堆栈组成。  
　3）线程是进程中的一个实体，是被系统独立调度和分配的基本单位。  
　4）线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程的全部资源。  
　5）一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。  

###Java中线程的三种基本用法
　1）自定义一个类，去继承Thread类，重写run方法。  
　2）自定义一个类，去实现Runnable接口，重写run方法。  
　3）自定义一个类，去实现Callable接口，重写call方法。  
　注意：Runnable中run方法无返回值且不能抛出异常，Callable中的call方法可返回一个Future对象且可以抛出异常。

###并行和并发  
#####1）并发(Concurrency)：  
　　 a.多个任务可在同一时间段内启动、运行和完成。  
　　 b.在宏观上并发看起来是同时进行，但在微观上(CPU中)是顺序执行的。  
　　 c.并发实质是一个(也可以是多个)物理CPU在多个线程间的复用，但在同一CPU中一个CPU时间片段上只能有一个线程在运行。  
　　 d.由于CPU运行速度快，使得多个任务在极短时间内同时完成，这一现象看起来像是任务的并行运行，但实际上在极小时间粒度(ns)上来看这些任务还是顺序执行的。
#####２）并行(Parallelism)：  
　　 a.并行是真正意义上的多个任务(线程)在宏观、微观中同一时刻运行。  
　　 b.并行只能发生在多核CPU的计算机上。  
　　 c.并行实质上是多个任务分别在多个CPU中在同一时间段内同时运行。  

###线程的五种状态
　1）新建状态：新创建了一个线程对象。  
　2）就绪状态：调用Thread类的start方法()启动一个线程之后，线程进入就绪状态。  
　3）运行状态：当就绪状态的线程获得CPU时间之后，进入运行状态。  
　4）阻塞状态：运行状态中的线程没有结束运行，暂时让出CPU，此时该线程进入阻塞状态，等待下次获得CPU时间。  
　　　a.线程通过调用sleep()方法进入睡眠状态（让出CPU执行权）  
　　　b.线程调用一个在I/O上被阻塞的操作，即该操作在I/O操作完成之前不会返回它的调用者  
　　　c.线程试图得到一个锁，而该锁正被其他线程持有  
　　　d.线程等待某个触发条件  
　5）死亡状态：线程的run()方法正常执行结束或者一个未捕获的异常使线程猝死后线程进入死亡状态。    

###线程的几个常用方法
　1）sleep()（线程睡眠）  
　　a.使当前线程睡眠指定的一段时间，若该线程持有同步锁（monitor），sleep不会让出该锁。  
　　b.线程睡眠到期后自动苏醒，并返回就绪状态，而不是运行状态。因此sleep()中指定的时间是线程不会运行的最短时间，sleep方法不能作为精确的时间控制。  
　　c.sleep是Thread类中的静态方法，可抛出异常，只能控制当前正在运行的线程。  
　　d.sleep(0)的作用是触发操作系统重新进行一次CPU竞争，重新计算优先级。竞争的结果也许是当前线程任然获得CPU控制权，也许是其他线程获得。  
　2）wait()（线程等待）  
　　a.使当前线程进入阻塞状态，该线程不可继续执行，同时让当前线程释放它所持有的锁。  
　　b.wait是Object类中的final方法，可抛出异常，最终执行wait(long timeout)方法，timeout为毫秒。  
　　c.存在重载方法wait(long timeout,int nanos)，nanos为纳秒。  
　　d.notify()、notifyAll()或者超过指定等待时间会使当前线程被唤醒进入就绪状态。  
　　e.wait方法只能在synchronized(obj){..}语句块中使用。  
　　f.在while循环里而不是if语句下使用wait，这样，会在线程暂停恢复后都检查wait的条件，并在条件实际并未改变的情况下处理唤醒通知。  
　3）notify()（线程唤醒）：  
　　a.唤醒等待该对象同步锁的线程。  
　　b.有多个线程等待同一个对象的锁时，由JVM随机唤醒其中一个线程，且不是按线程优先级。  
　　c.notifyAll是Object类中的final方法，可抛出异常。 
　　d.notify只能在synchronized(obj){..}语句块中使用。  
　　e.如果同时调用notify和wait方法时，必须先调用notify后调用wait，因为调用完wait方法，该线程已经不是currentThread了。  
　4）notifyAll()（线程唤醒）：  
　　a.唤醒所有等待该对象同步锁的线程。  
　　b.notifyAll是Object类中的final方法，可抛出异常。  
　5）yield()（线程让步）：  
　　a.使当前线程从运行状态变为就绪状态。  
　　b.sleep是Thread类中的静态native方法，无异常抛出。  
　　c.yield告诉当前正在执行的线程把运行机会交给线程池中拥有相同优先级的线程。  
　　d.yield让出CPU时间片后可能是其他线程开始运行也可能是此线程重新运行。  
　6）join()：  
　　a.将另一个线程A加入到当前线程，需要等A执行结束后才能继续执行当前线程。  
　　b.join为Thread类中的方法，可抛出异常。  