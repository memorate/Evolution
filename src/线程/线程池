###一、线程：
　1）线程，是程序执行的最小单元。  
　2）标准的线程由线程ID、当前指令指针、寄存器集合和堆栈组成。  
　3）线程是进程中的一个实体，是被系统独立调度和分配的基本单位。  
　4）线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程的全部资源。  
　5）一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。  

###二、Java中线程的三种基本用法
　1）自定义一个类，去继承Thread类，重写run方法。  
　2）自定义一个类，去实现Runnable接口，重写run方法。  
　3）自定义一个类，去实现Callable接口，重写call方法。  
　注意：Runnable中run方法无返回值且不能抛出异常，Callable中的call方法可返回一个Future对象且可以抛出异常。

###三、并行和并发  
#####1）并发(Concurrency)：  
　　 a.多个任务可在同一时间段内启动、运行和完成。  
　　 b.在宏观上并发看起来是同时进行，但在微观上(CPU中)是顺序执行的。  
　　 c.并发实质是一个(也可以是多个)物理CPU在多个线程间的复用，但在同一CPU中一个CPU时间片段上只能有一个线程在运行。  
　　 d.由于CPU运行速度快，使得多个任务在极短时间内同时完成，这一现象看起来像是任务的并行运行，但实际上在极小时间粒度(ns)上来看这些任务还是顺序执行的。
#####２）并行(Parallelism)：  
　　 a.并行是真正意义上的多个任务(线程)在宏观、微观中同一时刻运行。  
　　 b.并行只能发生在多核CPU的计算机上。  
　　 c.并行实质上是多个任务分别在多个CPU中在同一时间段内同时运行。  

###四、线程的五种状态
　1）新建状态：新创建了一个线程对象。  
　2）就绪状态：调用Thread类的start方法()启动一个线程之后，线程进入就绪状态。  
　3）运行状态：当就绪状态的线程获得CPU时间之后，进入运行状态。  
　4）阻塞状态：运行状态中的线程没有结束运行，暂时让出CPU，此时该线程进入阻塞状态，等待下次获得CPU时间。  
　　　a.线程通过调用sleep()方法进入睡眠状态（让出CPU执行权）  
　　　b.线程调用一个在I/O上被阻塞的操作，即该操作在I/O操作完成之前不会返回它的调用者  
　　　c.线程试图得到一个锁，而该锁正被其他线程持有  
　　　d.线程等待某个触发条件  
　5）死亡状态：线程的run()方法正常执行结束或者一个未捕获的异常使线程猝死后线程进入死亡状态。    

###五、线程的几个常用方法
#####1）sleep()（线程睡眠）--Thread类  
　　a.使当前线程睡眠指定的一段时间，若该线程持有同步锁（monitor），sleep()不会让出该锁。  
　　b.线程睡眠到期后自动苏醒，并返回就绪状态，而不是运行状态。因此sleep()中指定的时间是线程不会运行的最短时间，sleep方法不能作为精确的时间控制。  
　　c.sleep()是Thread类中的静态方法，可抛出异常，只能控制当前正在运行的线程。  
　　d.sleep(0)的作用是触发操作系统重新进行一次CPU竞争，重新计算优先级。竞争的结果也许是当前线程任然获得CPU控制权，也许是其他线程获得。  
#####2）wait()（线程等待）--Object类  
　　a.使当前线程进入阻塞状态，该线程不可继续执行，同时让当前线程释放它所持有的锁。  
　　b.wait()是Object类中的final方法，可抛出异常，最终执行wait(long timeout)方法，timeout为毫秒。  
　　c.存在重载方法wait(long timeout,int nanos)，nanos为纳秒。  
　　d.notify()、notifyAll()或者超过指定等待时间会使当前线程被唤醒进入就绪状态。  
　　e.wait()方法只能在synchronized(obj){..}语句块中使用。  
　　f.在while循环里而不是if语句下使用wait()，这样，会在线程暂停恢复后都检查wait()的条件，并在条件实际并未改变的情况下处理唤醒通知。  
#####3）notify()（线程唤醒）--Object类  
　　a.唤醒一个等待该对象同步锁的线程。  
　　b.有多个线程等待同一个对象的锁时，由JVM随机唤醒其中一个线程，且不是按线程优先级。  
　　c.notify()是Object类中的final方法，可抛出异常。  
　　d.notify()只能在synchronized(obj){..}语句块中使用。  
　　e.如果同时调用notify()和wait()方法时，必须先调用notify()后调用wait()，因为调用完wait()方法，该线程已经不是currentThread了。  
#####4）notifyAll()（线程唤醒）--Object类  
　　a.唤醒所有等待该对象同步锁的线程。  
　　b.虽然notifyAll()唤醒了一批线程，但最终只会有一个线程获得锁去运行。  
　　c.notifyAll()是Object类中的final方法，可抛出异常。  
#####5）yield()（线程让步）--Thread类  
　　a.使当前线程从运行状态变为就绪状态。  
　　b.yield()是Thread类中的静态native方法，无异常抛出。  
　　c.yield()告诉当前正在执行的线程把运行机会交给线程池中拥有相同优先级的线程。  
　　d.yield()让出CPU时间片后可能是其他线程开始运行也可能是此线程重新运行。  
#####6）join(线程插入)--Thread类  
　　a.将另一个线程A加入到当前线程，需要等A执行结束后才能继续执行当前线程。  
　　b.join()为Thread类中的方法，可抛出异常。  

###六、synchronized
#####1)互斥锁：
　　能达到互斥访问目的的锁。即当多个线程操作共享数据时，保证同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再进行。
#####2)synchronized的作用：
　　a.确保线程互斥访问同步代码。  
　　b.保证可见性（共享数据的变化可被其他线程看到）。  
#####3)synchronized的四种使用方式：
　　a.修饰一个代码块，被修饰的代码块称为同步语句块，其作用范围是{}内的代码，作用的对象是调用这个代码块的对象。  
　　b.修饰一个方法，被修饰的方法称为同步方法，其作用范围是整个方法，作用对象是调用这个方法的对象。  
　　c.修饰一个静态方法，其作用范围是整个静态方法，作用对象是这个类的所有对象。  
　　d.修饰一个类，其作用范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。  

###七、线程的start()和run()两种启动方式
1）run()启动  
　　threadOne.run()等同于调用普通类中的普通方法，会立即在主线程中运行run()方法内部的代码，等待run()方法结束后才能顺序执行下面代码，程序中只有主线程这一个线程，未达到多线程运行的目的。  
2）start()启动  
　　threadOne.start()是线程的标准启动方式，使threadOne进入线程就绪状态，而主线程无需等待run()方法执行完毕，可以直接继续执行下面的代码。但注意，此时threadOne是独立于主线程的另一线程，其并未立即执行，而是等待，在获得cpu时间后开始执行threadOne里run()方法内的代码，此时的方法run()称为线程体。